> module PuriiPOLIZ where

Національний університет "Києво-Могилянська академія"
                Факультет інформатики
            Функціональне програмуванння

                    Реферат                            
                    на тему
==================================================
Обрахування виразів в польському інверсному записі
==================================================
Виконав: ПУРІЙ Р. М.
Викладач: ПРОЦЕНКО В. С.

КИЇВ, 2017



ПЛАН
1. Поняття польського інверсного запису. - рядок 23
2. Реалізація функції обрахування ПІЗ на haskell. - рядок 48
3. Додавання до функції нових операторів. - рядок 90


==================================================
    1. Поняття польського інверсного запису.
==================================================

Інфіксна нотація математичних виразів виглядає так:
10 – (4 + 3) * 2
Це зручно, бо ми можемо обрахувати такий вираз подумки.
Але є і недоліки: щоб визначити пріоритет операцій,
доводить використовувати дужки ().

Польський інверсний запис (або постфіксна нотація) виглядає так:
10 4 3 + 2 * -
Тобто операції записуються після чисел.

Обрахувати це можна наступним чином:
1. Додаємо 10 у стек.
2. Додаємо 4 у стек.
3. Додаємо 3 у стек.
4. Зустріли +. Витягуємо 4 і 3 зі стеку і сумуємо = 7. Додаємо 7 у стек.
5. Додаємо 2 у стек.
6. Зустріли *. Витягуємо 7 і 2 зі стеку і множимо = 14. Додаємо 14 у стек.
7. Зустріли -. Витягуємо 10 і 14 зі стеку і віднімаємо = -4. Додаємо -4 у стек.
8. У стеці залишився тільки результат.


==================================================
2. Реалізація функції обрахування ПІЗ на haskell.
==================================================

Функція повинна приймати рядок, у якому польський запис,
і повертати число. Щоб використовувати операції на зразок
ділення, число має бути дійсним.

Отже, тип функції виглядатиме так:

> poliz :: String -> Double

1. Вище розглядали вхідний рядок як список з чисел
і операцій, тобто ділили на складові. У haskell перетворити
рядок на список слів (у нашому випадку чисел і операторів)
можна за допомогою функції words.

2. Далі ми проходили список зліва направо, працюючи зі стеком
по мірі проходження. Пройшовши весь список, у стеку отримали
результат. Фактично ми згорнули список елементів в один елемент.
У haskell лівосторонню згортку можна зробити за допомогою
функції foldl.

3. Стек реалізовувати не потрібно: можна скористатися списком.
Стек накопичуватиме результат в ході проходження, а поки нічого
не пройшли буде порожнім списком [].

> poliz input = head $ foldl foldElems   []      (words input)

Функція для згортки foldElems прийматиме стек і елемент, 
а повертатиме стек. Елемент може бути числом або операцією.
Оскільки для кожної операції, представленої рядком, потрібно
виконати відповідну функцію haskell, напишемо окремий зразок
foldElems для кожної з операцій. У іншому випадку вважатимемо,
що елемент — число.

>   where
>       foldElems (x:y:ys) "*" = (x * y):ys
>       foldElems (x:y:ys) "+" = (x + y):ys
>       foldElems (x:y:ys) "-" = (y - x):ys
>       foldElems (x:y:ys) "/" = (y / x):ys
>       foldElems (x:y:ys) "^" = (y ** x):ys

        foldElems xs nmbr = read nmbr:xs

==================================================
    3. Додавання до функції нових операторів.
==================================================

Оператори не обов'язково мають бути бінарними. Для прикладу,
додамо оператори "ln" — натуральний логарифм від числа;
і "sum" — сума всіх чисел, що є у стеку.

>       foldElems (x:xs) "ln" = log x:xs
>       foldElems xs "sum" = [sum xs]
>       foldElems xs nmbr = read nmbr:xs
